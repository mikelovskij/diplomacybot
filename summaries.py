import json
from config import RAW_TURNS_TO_KEEP, MAX_CHARS_PER_MSG, AI_COUNTRY
from typing import List, Dict
from openai_calls import call_openai

"""File containing helper functions for conversation summarization."""

def build_summary_prompt(ai_country: str, payload: dict) -> str:
    keys = list(payload.keys())
    keys_json = json.dumps(keys)
    return f"""
You update private Diplomacy negotiation summaries for {ai_country}.

CRITICAL RULES:
- Each country key is independent. NEVER move facts between keys.
- Only use information inside that key's "summary" and "recent".
- Preserve who offered what, keep track of all parts offers.
- If something is uncertain or tentative, mark it as such.
- Keep it short and factual: commitments, timelines, DMZs, proposed supports, open questions.
- Mark uncertainty clearly (firm vs tentative).

OUTPUT:
Return ONLY valid JSON: an object with EXACTLY these keys: {keys_json}
Each value must be a few lines of summary for that country, which considers the old summary and the most recent messages.
No extra keys, no commentary.

INPUT:
{json.dumps(payload)}
""".strip()

def messages_to_lines(messages: list[dict],
                      *,
                      ai_country: str,
                      player_country: str,
                      max_chars_per_msg: int = 1500,
                      ) -> list[str]:
    """
    Convert message objects to formatted text lines.
    
    Formats messages with role and country labels, truncating oversized content.
    
    :param messages: List of message dictionaries with 'role' and 'content' keys
    :param ai_country: Country name for AI messages
    :param player_country: Country name for player messages
    :param max_chars_per_msg: Maximum characters per message before truncation (default: 1500)
    :return: List of formatted message strings as "ROLE(COUNTRY): content"
    """
    lines: list[str] = []
    for m in messages:
        content = (m.get("content") or "").strip()
        if not content:
            continue
        if len(content) > max_chars_per_msg:
            content = content[:max_chars_per_msg] + "â€¦"

        role = m.get("role")
        if role == "user":
            lines.append(f"PLAYER({player_country}): {content}")
        else:
            lines.append(f"AI({ai_country}): {content}")
        lines.append("\n")
    return lines

def build_summary_payload(threads: list[dict],
                            *,
                            ai_country: str,
                            max_recent_msgs: int | None = None,
                         ) -> dict:
    """
    threads items expected keys:
      - country (str)
      - summary (str)
      - messages (list[dict])
    Returns payload keyed by country:
      { "Italy": {"summary": "...", "recent": [...]}, ... }
    """
    payload: dict = {}
    for th in threads:
        country = th["country"]
        summary = (th.get("summary") or "").strip()
        msgs = th.get("messages") or []
        if max_recent_msgs is not None:
            msgs = msgs[-max_recent_msgs:]

        payload[country] = {
            "summary": summary,
            "recent": messages_to_lines(
                msgs,
                ai_country=ai_country,
                player_country=country,
                max_chars_per_msg=MAX_CHARS_PER_MSG,
            ),
        }
    return payload

async def summarize_payload(ai_country: str, payload: dict) -> dict[str, str] | None:
    raw = await call_openai(
        system_prompt="You are a helpful summarizer.",
        user_text=build_summary_prompt(ai_country, payload),
    )
    return parse_summaries(raw, expected_keys=list(payload.keys()))

def parse_summaries(text: str, expected_keys: list[str]) -> dict[str, str] | None:
    """Parses summary JSON text generated by summarize_payload,
      ensuring it has the expected keys with string values.
      """
    try:
        data = json.loads(text)
    except Exception:
        return None
    if not isinstance(data, dict):
        return None
    if set(data.keys()) != set(expected_keys):
        return None
    out = {}
    for k in expected_keys:
        v = data.get(k)
        if not isinstance(v, str):
            return None
        out[k] = v.strip()
    return out
    
async def maybe_summarize_thread(current_summary: str, user_country: str, messages: List[Dict]) -> tuple[str, bool]:
    # Only summarize when too long
    if len(messages) <= RAW_TURNS_TO_KEEP:
        return current_summary, False

    # Keep last half as raw tail
    keep = max(2, RAW_TURNS_TO_KEEP // 2)
    older = messages[:-keep]
    newer = messages[-keep:]

    payload = build_summary_payload(
        [{"country": user_country, "summary": current_summary, "messages": older}],
        ai_country=AI_COUNTRY,
        max_recent_msgs=None,
    )
    updated = await summarize_payload(AI_COUNTRY, payload)

    # Default to existing summary if summarizer fails
    new_summary = current_summary
    if updated and user_country in updated:
        new_summary = updated[user_country].strip()
        messages[:] = newer  # truncate in place

    return new_summary, True